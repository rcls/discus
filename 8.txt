Registers:
A
X
Y
U

Buses
 - V operand / address
 - B mem read
 - mem write (A,A# off CPU).

V bus - complementary signalling, flip-flop driven, active LOW.
 (address decodes will have CMOS inverters to drive the fan-out...)
B bus - open drain
mem write - needs write strobe (clock phase 2).

A0..7 & # : Accumulator value.
V0..7 & # : Operand / address.
B0#..B7# : Operand (B-input to ALU).

P0..P7 & # : Program counter.
O0#..O7# : Opcode (from ROM).
J0..J6 & # : Opcode (1 cycle delay from ROM).

ϕ0, ϕ1 : Clocks : Rising edge ϕ0 drives CPU logic, rising edge ϕ1 drives PC
logic.
C0, C1 : Clock source input.

PK : Tell CPU board that constant is valid (& hence jmp/call is possible).
FC : Carry flag out.
FZ : Zero flag out.
STA# : Store to memory (internal link).
MR : Memory read strobe.
MW : Memory write strobe to RAM (synchronous to clock).



source bus is register or constant.  Memory address is always source bus.
operand bus is source bus direct or memory lookup
result bus is ALU output, or operand bus direct (add 0...)

00XXXXXX - data prefix (load immediate register).
  * any other instruction clears data prefix.

00LCCCxx - with prefix, jump, opt link.

01AAAMRR - ins that r/w A. (flags Z C O?)
  * 7 basic operations:
     add(c) sub(c) or and xor
  * also possibly cmp or sta?
  * probably don't need sub...


00 - prefix or jmp/call constant. (Inc. uncond.)
00LCCCxx - call(L=0) or jmp(L=1).
01AAAMRR - ops that r/w A.
100WWMRR - Load WW = src, no flags.
110WWMRR - WW = src-1, flag Z.
111WWMRR - WW = src+1, flag Z.

101CCCxx - ret.
101010xx - uncond ret.

101000xx - IN, to make the reg = A (saves decode...), keep ram off bus.

101001xx - STA - note M bit is set, memory read will be ignored.
101011xx - OUT - note M bit is set, ignore memory read.

AAA = 000 : ADD
AAA = 001 : ADC
AAA = 010 : SUB
AAA = 011 : SBC
AAA = 100 : OR
AAA = 101 : XOR
AAA = 110 : AND
AAA = 111 : CMP


CCC = 000 : always [but not ret]
CCC = 001 : never (unittest as don't care for jump/call).
CCC = 010 : always (unittest for ret, don't care for jump/call).
CCC = 011 : never (unittest for ret, don't care for jump/call).
CCC = 100 : z
CCC = 101 : nz
CCC = 110 : c
CCC = 111 : nc


A : 00
X : 01
Y : 10
U : 11

01xxxxxx : write A
(100/11x)WWxxx : write WW.


Out can just use V or B bus. (V->Out, In->B?)

constant latch 0,1 also can serve for reg write address latch.

Put the VR strobe into the read-select strobes (push-pull)?

Fixme - Z flag...


Decode signals...

AR#
AS
CS#
CR
[also CinS#, CinR...]XF
N
C-latch
VK - V taken from K (i.e., previous ins was constant).
BV - B# taken from V bus (i.e., not memory read, i2#).
AND
OR

O4# - Flag = 0
O3#, O4 - Flag = FZ#
O3, O4 - Flag = FC#

N - high only for SUB, SBC and CMP
OR - high only for OR
AND - high only for AND

C - high for AND, low for OR, XOR...

Cin - force high for AND, SUB, CMP, INC
 - force low for ADD, DEC, OR, XOR

straight though:
Either ADD, OR, XOR with A=0, [CR don't care for ADD].
Or AND with A=255.

BV - if B not coming from memory or I/O port.

Write reg:

 01xxxxxx except 01110xxx (cmp)
 1xxxxxxx except 101xxxxx
 also IN (some 101xxxxx).

[~7 & 6 & (~5 | ~4 | 3)]  |  [7 & (~6 | 5 | IN)]

C is written by 01xxxxxx
Z is written by everything that writes a reg, plus cmp
   except: move (100xxxxxx), in (some 101xxxxx).
   i.e. x1xxxxxx

Load mem (many don't care): 01xxx1xx, 1xxxx1xx except some 101xx1xx
Use i2, don't care about exceptions, specials get it right.

IN is a do care (we want the bus...)


AND is high for 01110xxx
is low for 1xxxxxxx
don't care 00xxxxxx
So take 0x110xxx

OR# is low for 01100xxx
don't care 00xxxxxx
Take 0x100xxx

AS is high for DEC: 110xxxxx
AS dominates
AR# is low for INC,MV, 100xxxxx, 111xxxxx, For IN: all 101xxxxx, simplifies to:
  1xxxxxxx



CS - high for AND (anything else?), 0x101xxx
CR# - low for OR, XOR, 0x100xxx, 0x101xxx, i.e.
   0x10xxxx,
Also special 1010xxxx... simplifies x010xxxx


CinForce - ADD, SUB, OR, AND, XOR, CMP, all INC,DEC,MV,spec...
 1xxxxxxx, xx1xxxxxx, xxxx0xxx

CinS: CinForce &
 0[1]x10xxx (SUB, AND)
 0[1]11xxxx (CMP, AND)
 1 1 1xxxxx (DEC)
[CinS dominant.]

N - assert for SUB, SBC, CMP: 0x00xxxx, 0x[1]00xxx

WZ - assert for 01xxxxxx, 11xxxxxx, i.e, i6.

Write : not jump except ret/write/STA/OUT.
x1xxxxxx,1x0xxxxx,IN

FIXME : Various flags could be (comp-) open drain.
FIXME : AS/AR CS/CR dominances broken?
FIXME : Check perf. of pull strobes.
FIXME : PE in rom128byte.sch - push-pull or a trannie?
FIXME : Put reset on the pc board.
FIXME : Does SRAM really need the double-buffer on output?
FIXME : Pullup resistors.
FIXME : Buffers on FC/FZ?
FIXME : we should probably only write strobe the stack latches during phi0.
FIXME : those glitches on FZ are yuck.  Use a proper Dflop instead.
FIXME : vdilatch driving the regs is dodgy too...

FIXME : Is the gating on SRAM MR -> RD# required?  We already have the select
strobes, so we could rely on that and just set RD# = !MR?

FIXME : Do we have races on the PUSH strobe for the stack?

TODO : Caps, osc, clocking on integration.
TODO : OUT buffer/latch?

ROM uses PNP on SEL#, RAM uses P-channel .... which is better?

