registers

SS/RR registers:
A
X
Y
Z - constant generator, reads as op specific value, zero unless other stated.

S (sacc) register is loaded by explicit sacc op, or any write to A.  Implicit
first operand to all ALU ops.

DD is two bits, specifies which register next op sets.  Reset to zero
on all ops except the ones that explicitly load it.

Buses
 - operand / address
 - mem read / transfer
 - mem write

Operand bus is also address bus.



memory connector (32 bytes):
8 w1
8 w0
8 r
8 row sel
4 col sel
= 36 .... so a 40 pin connector (1mm one sided? or even 2.54mm?)

source bus is register or constant.  Memory address is always source bus.
operand bus is source bus direct or memory lookup
result bus is ALU output, or operand bus or link register

* sacculator normally latches same value as accumulator, except for explicitly
  setting sacculator.

* ALU uses sacculator and operand bus.

00XXXXXX - data prefix (load immediate register).
  * any other instruction clears data prefix.

01UUUMSS - alu op (ALU output indirect to register DD).
  * clear DD bits.
  * leave sacc==A

10CCCLSS - jump/call (source bus to PC).
  Z means return, what does return with link mean?
  10000xxx are jump-never - can do special things (set/reset clr?)
CCC - one bit is jump-on-set/not-set, two bits source, 00 is always/never.
Traditional C/Z/N flags.

110RR0SS - store RR to memory (extra register to memory write).

110DD1SS - load sacc., set destination.
    (result bus to sacculator, load DD bits).

111RRMSS - load RR with operand (result bus to register RR).
    [Does RR=11 have same meaning as an ALU op with DD=11?]


register file is single write (off result bus).
Write register is RR bits, or DD bits or accumulator.

register file is dual read (sacculator has drive to ALU only):
  source bus.
  memory write value (or PC for PC to link).

registers are A X Y Z.  Z is a magic constant;
Writes to Z do something magic?  LEDs? / I/O?

phase1 - register outputs are transparent.
phase2 - register inputs & misc latches are transparent.

Instruction lookup address is pc 'input latch'.  Instruction latch is
transparent on phase1.


add Z means increment.
sub Z means decrement.  i.e., Z reads as 1 for add/sub

add/inc
sub/dec/neg
adc
sbc
or - do something funky on 'or Z' - read IOs? (orA just tests?)
and - (andZ right shifts?, andA right shifts with carry?)
xor - Z reads as 0xff.
cmp

inc/dec preserve C?

call Z gives 8 specials...
maybe jump-never is special?

CCC

* always/never
* IO0, notIO0
* C, notC
* Z, notC

* Could have stack instead of link register. For jumps Z reads as stack top.


Reset sequence?...

ld A,Z
ld X,Z
ld L,Z
st A,(X)
inc X
jnz $-2
jmp 1
